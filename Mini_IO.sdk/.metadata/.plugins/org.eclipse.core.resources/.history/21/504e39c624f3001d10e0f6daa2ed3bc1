#include "xil_io.h"
#include "xintc_l.h"
#include "xspi_l.h"
#include "xparameters.h"
#include "xtmrctr.h"

#define Sw_DATA 0x40000000
#define Sw_TRI  0x40000004
#define Sw_ISR  0x40000120
#define Sw_GIER 0x4000011C // Switch 全局中断允许寄存器地址
#define Sw_IER 0x40000128 // Switch 通道中断允许寄存器地址

#define Led_DATA 0x40000008
#define Led_TRI 0x4000000C

#define Bt_DATA 0x40010000
#define Bt_TRI 0x40010004
#define Bt_ISR  0x40010120
#define Bt_GIER 0x4001011C // Switch 全局中断允许寄存器地址
#define Bt_IER 0x40010128 // Switch 通道中断允许寄存器地址

#define An_DATA 0x40020000
#define An_TRI 0x40020004

#define Seg_DATA 0x40020008
#define Seg_TRI 0x4002000C

#define T0_RESET_VALUE 10000//1s

#define intc_ISR 0x41200000
#define intc_IER 0x41200008
#define intc_IAR 0x4120000C
#define intc_MER 0x4120001C

//注册总中断服务程序
void My_ISR(void) __attribute__((interrupt_handler));
void initialize(void);
void SwitchHandler(void);
void ButtonHandler(void);
void TimerHandler(void);

//全局变量定义
u16 segcode[16]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e};//显示缓冲区
u16 poscode[8]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};//位码表
u16 TimeFlag;
u16 i;
u16 tcsr0;
u16 count;
u16 data;
u16 Sign;
u16 begin;

//主函数
int main(void){
	xil_printf("running the main function\r\n");
	initialize();
	while(1)
	{
		//xil_printf("i is 0x%X\r\n",i);
		if(TimeFlag==1)
		{
			TimeFlag==0;
			if(begin == 1)
			{
				Xil_Out32(An_DATA,poscode[i]);
				Xil_Out32(Seg_DATA,segcode[((data>>i*4)&0xf)]);
			}
		}
	}
}


//初始化函数
void initialize(void)
{
	TimeFlag=0;
	i=0;
	k=0;
	begin=0;
	//Timer0初始化
	tcsr0=Xil_In32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET);
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET,tcsr0&(~XTC_CSR_ENABLE_TMR_MASK)); // ENT = 0, 停止计时
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TLR_OFFSET,T0_RESET_VALUE); // *写LDR, 配置计数初始值*

	tcsr0=Xil_In32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET);
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET,tcsr0|XTC_CSR_LOAD_MASK); // LODA = 1，装载TLR到TCR
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET,tcsr0| ((XTC_CSR_ENABLE_TMR_MASK|XTC_CSR_DOWN_COUNT_MASK // ENT =1，运行定时器，UDT = 1, 减计数
		|XTC_CSR_AUTO_RELOAD_MASK)&(~XTC_CSR_LOAD_MASK))); // 自动装载：ARHT=1,LOAD =0;

	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET,
	Xil_In32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET )|XTC_CSR_INT_OCCURED_MASK| XTC_CSR_ENABLE_INT_MASK); // 清除中断标志：TINT=1;允许TIMER中断：ENINT=1；

	/*//Timer1初始化
	tcsr0=Xil_In32(XPAR_TMRCTR_0_BASEADDR+XTC_TIMER_COUNTER_OFFSET+XTC_TCSR_OFFSET);
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TIMER_COUNTER_OFFSET+XTC_TCSR_OFFSET,tcsr0&(~XTC_CSR_ENABLE_TMR_MASK)); // ENT = 0, 停止计时
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TIMER_COUNTER_OFFSET+XTC_TLR_OFFSET,T1_RESET_VALUE); // *写LDR, 配置计数初始值*

	tcsr0=Xil_In32(XPAR_TMRCTR_0_BASEADDR+XTC_TIMER_COUNTER_OFFSET+XTC_TCSR_OFFSET);
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TIMER_COUNTER_OFFSET+XTC_TCSR_OFFSET,tcsr0|XTC_CSR_LOAD_MASK); // LODA = 1，装载TLR到TCR
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TIMER_COUNTER_OFFSET+XTC_TCSR_OFFSET,tcsr0| ((XTC_CSR_ENABLE_TMR_MASK|XTC_CSR_DOWN_COUNT_MASK // ENT =1，运行定时器，UDT = 1, 减计数
		|XTC_CSR_AUTO_RELOAD_MASK)&(~XTC_CSR_LOAD_MASK))); // 自动装载：ARHT=1,LOAD =0;

	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TIMER_COUNTER_OFFSET+XTC_TCSR_OFFSET,
	Xil_In32(XPAR_TMRCTR_0_BASEADDR+XTC_TIMER_COUNTER_OFFSET+XTC_TCSR_OFFSET)|XTC_CSR_INT_OCCURED_MASK| XTC_CSR_ENABLE_INT_MASK); // 清除中断标志：TINT=1;允许TIMER中断：ENINT=1；
*/


	//Sw初始化，Bt初始化，Led初始化，数码管初始化
	Xil_Out16(Sw_TRI,0xffff);	//Sw输入信号;
	Xil_Out16(Led_TRI,0x0);		//Led输出信号;
	Xil_Out32(Bt_TRI,0x1f); 	//Bt输入信号;
	Xil_Out32(An_TRI,0x0);		//An输出信号;
	Xil_Out32(Seg_TRI,0x0);		//Seg输出信号;

	//GPIO模块初始化
	Xil_Out32(Sw_IER,0x01); //允许GPIO模块通道1中断
	Xil_Out32(Sw_GIER,0x80000000); //允许GPIO模块总中断
	Xil_Out32(Bt_IER,0x01); //允许GPIO模块通道1中断
	Xil_Out32(Bt_GIER,0x80000000); //允许GPIO模块总中断

	//中断控制器初始化
	Xil_Out32(intc_IAR,0xffffffff); //清零所有中断标志
	Xil_Out32(intc_IER,0x281);		//中断通道
	Xil_Out32(intc_MER,XIN_INT_MASTER_ENABLE_MASK|XIN_INT_HARDWARE_ENABLE_MASK);

	//CPU允许中断
	microblaze_enable_interrupts(); // 允许CPU中断
}

//中断服务子程序
void My_ISR(void)
{
	int Status;
	//xil_printf("running the interrupt!\r\n");
	Status = Xil_In32(intc_ISR);
	if((Status&0x01)==0x01)
	{
		SwitchHandler();
	}
	if((Status&0x80)==0x80)
	{
		ButtonHandler();
	}
	if((Status&0x200)==0x200)
	{
		TimerHandler();
	}

	if(Sign==1)
	{
		count++;
		if(count==10000)
		{
			data++;
			count=0;
		}
	}

	i++;
	if(i==2)
	{
		i=0;
	}
	Xil_Out32(intc_IAR,Status);
}

void SwitchHandler(void)
{
	data = Xil_In32(Sw_DATA);
	Xil_Out32(Led_DATA,Xil_In32(Sw_DATA));
	Xil_Out32(Sw_ISR,0x01);
}

void ButtonHandler(void)
{
	if((Xil_In32(Bt_DATA)&0x1f) != 0)
	{
		delay();
		if(Xil_In32(Bt_DATA)==0x1)
		{
			Sign=0;
			begin=1;
		}
		if(Xil_In32(Bt_DATA)==0x4)
		{
			Sign=1;
		}
	}
	Xil_Out32(Bt_ISR,0x01);
}

void TimerHandler(void)
{
	TimeFlag = 1;
	Xil_Out32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET,Xil_In32(XPAR_TMRCTR_0_BASEADDR+XTC_TCSR_OFFSET )|XTC_CSR_INT_OCCURED_MASK| XTC_CSR_ENABLE_INT_MASK); // 清除中断标志：写TINT=1;
}

void delay(void)
{
	for(int i=0;i<500000;i++);
}
