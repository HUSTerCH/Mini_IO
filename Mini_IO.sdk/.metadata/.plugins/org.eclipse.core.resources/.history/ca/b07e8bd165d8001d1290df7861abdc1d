/*
 * ProgramControl.c
 *
 *  Created on: Apr 11, 2023
 *      Author: Luo Chang
 */

#include <stdio.h>
#include "xil_printf.h"
#include "xil_io.h"
#include "xgpio_l.h"

// 显示数码管
void display(char segcode[], short tmp[], short pos, int k) {
    // k为移位个数
    for (int i = 0; i < 8; i++) {
        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR + XGPIO_DATA2_OFFSET, segcode[tmp[(i + k) % 8]]);  // 输出段选
        Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR + XGPIO_DATA_OFFSET, pos);  // 输出片选
        for (int j = 0; j < 10000; j++);  // 从高位到低位点亮8个数码管
        pos = pos >> 1;
    }
}

int main() {
    unsigned short last_sw, current_sw;  // 分别记录上次开关状态和本次开关状态
    unsigned short led;  // 输出到LED
    Xil_Out16(XPAR_AXI_GPIO_0_BASEADDR + XGPIO_TRI_OFFSET, 0xffff);  // 开关设为输入
    Xil_Out16(XPAR_AXI_GPIO_0_BASEADDR + XGPIO_TRI2_OFFSET, 0x0);  // LED设为输出

    unsigned short current_btn, last_btn, real_btn;  // 分别记录上次开关按下、弹起状态和真正弹起的开关
    char segcode[6] = {0xc1, 0xc7, 0xc0, 0x88, 0xc6, 0xff};  // 分别对应 {U, L, D, R, C, null}
    short tmp[8] = {5, 5, 5, 5, 5, 5, 5, 5};  // 初始不显示，8个数码管均为null
    int k = 0;  // 移位个数
    short pos = 0xff7f;
    Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR + XGPIO_TRI_OFFSET, 0x0);
    Xil_Out8(XPAR_AXI_GPIO_1_BASEADDR + XGPIO_TRI2_OFFSET, 0x0);
    Xil_Out16(XPAR_AXI_GPIO_2_BASEADDR + XGPIO_TRI_OFFSET, 0x1f);
    while (1) {
        last_sw = current_sw;
        current_sw = Xil_In16(XPAR_AXI_GPIO_0_BASEADDR + XGPIO_DATA_OFFSET) & 0xffff;
        if (last_sw != current_sw) {  // 开关改变时赋值
            led = current_sw;
        }
        Xil_Out16(XPAR_AXI_GPIO_0_BASEADDR + XGPIO_DATA2_OFFSET, led);  // 输出到LED

        display(segcode, tmp, pos, k);  // 显示数码管
        pos = 0xff7f;
        current_btn = Xil_In8(XPAR_AXI_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET) & 0x1f;
        if (current_btn) {  // 按键按下
            while (current_btn) {  // 按键未弹起
                display(segcode, tmp, pos, k);
                current_btn = (Xil_In8(XPAR_AXI_GPIO_2_BASEADDR + XGPIO_DATA_OFFSET) & 0x1f);
                real_btn = (current_btn ^ last_btn) & last_btn;  // 得到弹起的按键，可以在多个按键按下时判断得到弹起的开关
                last_btn = current_btn;
                if (real_btn) {
                    break;
                }
            }
            // 判断是哪个开关弹起
            switch (real_btn) {
            case 0x01: {
                tmp[k] = 0;
                k = (k + 1) % 8;
                break;
            }
            case 0x02: {
                tmp[k] = 1;
                k = (k + 1) % 8;
                break;
            }
            case 0x04: {
                tmp[k] = 2;
                k = (k + 1) % 8;
                break;
            }
            case 0x08: {
                tmp[k] = 3;
                k = (k + 1) % 8;
                break;
            }
            case 0x10: {
                tmp[k] = 4;
                k = (k + 1) % 8;
                break;
            }
            }
        }
    }
    return 0;
}
